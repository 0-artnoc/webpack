/*
	MIT License http://www.opensource.org/licenses/mit-license.php
*/

"use strict";

const path = require("path");

/**
 * @typedef {Object} MakeRelativePathsCache
 * @property {Map<string, Map<string, string>>=} relativePaths
 */

/**
 * @param {string} context context for relative path
 * @param {string} maybeAbsolutePath path to make relative
 * @returns {string} relative path in request style
 */
const absoluteToRequest = (context, maybeAbsolutePath) => {
	if (/^\/.*\/$/.test(maybeAbsolutePath)) {
		// this 'path' is actually a regexp generated by dynamic requires.
		// Don't treat it as an absolute path.
		return maybeAbsolutePath;
	}
	if (/^[a-zA-Z]:\\/.test(maybeAbsolutePath)) {
		const splitPath = maybeAbsolutePath.split("?", 2);
		splitPath[0] = path.win32.relative(context, splitPath[0]);
		if (!/^[a-zA-Z]:\\/.test(splitPath[0])) {
			splitPath[0] = splitPath[0].replace(/\\/g, "/");
			if (!/^\.\.\//.test(splitPath[0])) {
				splitPath[0] = "./" + splitPath[0];
			}
		}
		return splitPath.join("?");
	} else if (/^\//.test(maybeAbsolutePath)) {
		const splitPath = maybeAbsolutePath.split("?", 2);
		splitPath[0] = path.posix.relative(context, splitPath[0]);
		if (!/^\.\.\//.test(splitPath[0])) {
			splitPath[0] = "./" + splitPath[0];
		}
		return splitPath.join("?");
	} else {
		// not an absolute path
		return maybeAbsolutePath;
	}
};

/**
 *
 * @param {string} context context for relative path
 * @param {string} identifier identifier for path
 * @returns {string} a converted relative path
 */
const _makePathsRelative = (context, identifier) => {
	return identifier
		.split(/([|!])/)
		.map(str => absoluteToRequest(context, str))
		.join("");
};

const makePathsRelativeCache = new WeakMap();

/**
 *
 * @param {string} context context used to create relative path
 * @param {string} identifier identifier used to create relative path
 * @param {Object=} associatedObjectForCache an object to which the cache will be attached
 * @returns {string} the returned relative path
 */
exports.makePathsRelative = (context, identifier, associatedObjectForCache) => {
	if (!associatedObjectForCache) return _makePathsRelative(context, identifier);

	let relativePaths = makePathsRelativeCache.get(associatedObjectForCache);
	if (relativePaths === undefined) {
		relativePaths = new Map();
		makePathsRelativeCache.set(associatedObjectForCache, relativePaths);
	}

	let cachedResult;
	let contextCache = relativePaths.get(context);
	if (contextCache === undefined) {
		relativePaths.set(context, (contextCache = new Map()));
	} else {
		cachedResult = contextCache.get(identifier);
	}

	if (cachedResult !== undefined) {
		return cachedResult;
	} else {
		const relativePath = _makePathsRelative(context, identifier);
		contextCache.set(identifier, relativePath);
		return relativePath;
	}
};

/**
 * @param {string} context absolute context path
 * @param {string} request any request string may containing absolute paths, query string, etc.
 * @returns {string} a new request string avoiding absolute paths when possible
 */
const contextify = (context, request) => {
	return request
		.split("!")
		.map(r => absoluteToRequest(context, r))
		.join("!");
};
exports.contextify = contextify;
